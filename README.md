# intern-server-core-test-task
Моё тестовое задание на позицию Intern Server Core Programmer.

## Задание
### Вопрос №1

На языке Python или C++ написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 
```python
def isEven(value):
      return value % 2 == 0
```

### Вопрос №2
На языке Python или С++ написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

Оценивается:
- Полнота и качество реализации
- Оформление кода
- Наличие сравнения и пояснения по быстродействию
   
### Вопрос №3
На языке Python или С++ предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

## Архитектурные решения
### Задание №1
Вместо деления с остатком было принято решение сделать "побитовое и" на 1. Дело в том, что по "нулевому" биту можно определять четность/нечетность числа. Если этот бит == 1, то число нечетное, если == 0, то число четное. Чтобы узнать значение этого бита, а точнее, отчистить от остальной значащей части используется побитовое и на маску. В данном случае в качестве маски используется 1. На выходе у нас получается булевое значение, которое отвечает на вопрос: является ли данное число нечетным. Чтобы проверить число на четность нужно проотрицать его нечетность. В качестве отрицания я решил использовать булевое отрицание а не побитовое. Такой выбор я обусловил меньшим размером байткода после компиляции.

### Задание №2
В задании было сказано, что необходимо сделать 2 реализации. Я сделал одну реализацию в односвязном списку, а другую в массиве. 
Временные сложности:
|Метод|Списочная|Массивная|
|----|----|----|
|проверка<br>на пустость|О(1)|О(1)|
|добавление<br>элемента|O(1)|O(1)|
|удаление<br>элемента|O(1)|O(1)|
|получение<br>начала списка|O(1)|O(1)|
|получение<br>конца списка|O(1)|O(1)|
|получение<br>начала списка в глубину|O(1)|O(2n)|
|получение<br>конца списка|O(1)|O(n)|

Из плюсов реализации односвязная очередь: может рости пока не закончится куча. Из плюсов реализации массивной очереди: временная сложность получения n'ного элемента с начала или конца ровна О(1).

### Задание №3
В качестве реализации сортировки, я решил выбрать реализацию быстрой сортировки. Данная реализация отличается от обычной тем, что тут вместо двух массивов для разделения используются 3. В обчной реализации во время сортировки в первый массив идут те элементы, что меньше опорного, а остальные во второй. В моей реализации в первый массив идут числа меньше опорного, во второй равне опорному, а в третий массив больше опорного. Такая реализация позволяет работать быстрее на массивах, где к примеру, все числа равны или на какой-нибудь итерации большая часть чисел равна опорномоу, это позволяет уменьшить количество уходов в глубину. Кроме того, в рамках моей реализации берутся элементы выбор опорного элемента не константен. Берутся элементы первый, последний и стоящий в серидине и из них выбирается средний.
